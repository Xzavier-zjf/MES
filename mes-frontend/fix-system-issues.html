<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MESç³»ç»Ÿé—®é¢˜ä¿®å¤å·¥å…·</title>
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            padding: 24px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e4e7ed;
        }
        .section {
            margin-bottom: 30px;
        }
        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #303133;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }
        .status-healthy { background-color: #67c23a; }
        .status-warning { background-color: #e6a23c; }
        .status-critical { background-color: #f56c6c; }
        .status-unknown { background-color: #909399; }
        .check-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border: 1px solid #e4e7ed;
            border-radius: 6px;
            margin-bottom: 8px;
        }
        .check-item.pass { border-color: #67c23a; background-color: #f0f9ff; }
        .check-item.warning { border-color: #e6a23c; background-color: #fdf6ec; }
        .check-item.fail { border-color: #f56c6c; background-color: #fef0f0; }
        .log-area {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 16px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <div class="header">
                <h1>ğŸ”§ MESç³»ç»Ÿé—®é¢˜ä¿®å¤å·¥å…·</h1>
                <p>è‡ªåŠ¨æ£€æµ‹å’Œä¿®å¤ç³»ç»Ÿä¸­çš„å„ç§é—®é¢˜</p>
            </div>      
      <div class="section">
                <div class="section-title">
                    <span class="status-indicator" :class="`status-${systemHealth}`"></span>
                    ç³»ç»Ÿå¥åº·çŠ¶æ€
                </div>
                <el-row :gutter="20">
                    <el-col :span="6">
                        <el-card>
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: bold; color: #409eff;">{{ healthScore }}</div>
                                <div style="color: #909399;">å¥åº·è¯„åˆ†</div>
                            </div>
                        </el-card>
                    </el-col>
                    <el-col :span="6">
                        <el-card>
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: bold; color: #f56c6c;">{{ criticalIssues }}</div>
                                <div style="color: #909399;">ä¸¥é‡é—®é¢˜</div>
                            </div>
                        </el-card>
                    </el-col>
                    <el-col :span="6">
                        <el-card>
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: bold; color: #e6a23c;">{{ warnings }}</div>
                                <div style="color: #909399;">è­¦å‘Š</div>
                            </div>
                        </el-card>
                    </el-col>
                    <el-col :span="6">
                        <el-card>
                            <div style="text-align: center;">
                                <div style="font-size: 24px; font-weight: bold; color: #67c23a;">{{ fixedIssues }}</div>
                                <div style="color: #909399;">å·²ä¿®å¤</div>
                            </div>
                        </el-card>
                    </el-col>
                </el-row>
            </div>

            <div class="section">
                <div class="section-title">ğŸ” ç³»ç»Ÿæ£€æŸ¥</div>
                <el-space direction="vertical" style="width: 100%;">
                    <el-button type="primary" @click="performHealthCheck" :loading="isChecking">
                        æ‰§è¡Œå…¨é¢å¥åº·æ£€æŸ¥
                    </el-button>
                    <el-button type="success" @click="autoFixIssues" :loading="isFixing" :disabled="!canAutoFix">
                        è‡ªåŠ¨ä¿®å¤é—®é¢˜
                    </el-button>
                    <el-button type="info" @click="generateReport">
                        ç”Ÿæˆæ£€æŸ¥æŠ¥å‘Š
                    </el-button>
                </el-space>
            </div>

            <div class="section" v-if="checkResults">
                <div class="section-title">ğŸ“‹ æ£€æŸ¥ç»“æœ</div>
                <div v-for="(check, key) in checkResults.checks" :key="key" 
                     class="check-item" :class="check.status">
                    <div>
                        <strong>{{ check.name }}</strong>
                        <div style="font-size: 12px; color: #909399; margin-top: 4px;">
                            {{ getCheckDescription(check) }}
                        </div>
                    </div>
                    <div>
                        <el-tag :type="getTagType(check.status)">{{ getStatusText(check.status) }}</el-tag>
                        <el-button v-if="check.status !== 'pass'" size="small" type="text" 
                                   @click="showCheckDetails(check)">
                            è¯¦æƒ…
                        </el-button>
                    </div>
                </div>
            </div>

            <div class="section" v-if="suggestions.length > 0">
                <div class="section-title">ğŸ’¡ ä¿®å¤å»ºè®®</div>
                <el-alert v-for="suggestion in suggestions" :key="suggestion.title"
                          :title="suggestion.title" :description="suggestion.description"
                          :type="getSuggestionType(suggestion.priority)" show-icon
                          style="margin-bottom: 12px;">
                    <template #default>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: 600;">{{ suggestion.title }}</div>
                                <div style="margin-top: 4px;">{{ suggestion.description }}</div>
                            </div>
                            <el-button size="small" type="primary" @click="applySuggestion(suggestion)">
                                åº”ç”¨ä¿®å¤
                            </el-button>
                        </div>
                    </template>
                </el-alert>
            </div>

            <div class="section">
                <div class="section-title">ğŸ“ æ“ä½œæ—¥å¿—</div>
                <div class="log-area" ref="logArea">{{ logContent }}</div>
                <el-button size="small" @click="clearLog" style="margin-top: 8px;">æ¸…ç©ºæ—¥å¿—</el-button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus/dist/index.full.js"></script>
    <script>
        const { createApp, ref, computed, onMounted, nextTick } = Vue;
        const { ElMessage, ElNotification, ElMessageBox } = ElementPlus;

        createApp({
            setup() {
                const isChecking = ref(false);
                const isFixing = ref(false);
                const checkResults = ref(null);
                const suggestions = ref([]);
                const logContent = ref('ç³»ç»Ÿé—®é¢˜ä¿®å¤å·¥å…·å·²å¯åŠ¨\n');
                const logArea = ref(null);
                const fixedIssues = ref(0);

                // æ¨¡æ‹Ÿç³»ç»Ÿæ•°æ®
                const systemData = ref({
                    tasks: [],
                    injectionParams: [],
                    patterns: [],
                    plans: []
                });

                const systemHealth = computed(() => {
                    if (!checkResults.value) return 'unknown';
                    return checkResults.value.overallHealth;
                });

                const healthScore = computed(() => {
                    if (!checkResults.value) return 0;
                    return calculateHealthScore(checkResults.value);
                });

                const criticalIssues = computed(() => {
                    if (!checkResults.value) return 0;
                    return checkResults.value.issues.length;
                });

                const warnings = computed(() => {
                    if (!checkResults.value) return 0;
                    return checkResults.value.warnings.length;
                });

                const canAutoFix = computed(() => {
                    return suggestions.value.some(s => s.action && s.action.startsWith('auto'));
                });

                const addLog = (message) => {
                    const timestamp = new Date().toLocaleTimeString();
                    logContent.value += `[${timestamp}] ${message}\n`;
                    nextTick(() => {
                        if (logArea.value) {
                            logArea.value.scrollTop = logArea.value.scrollHeight;
                        }
                    });
                };

                const loadSystemData = async () => {
                    try {
                        addLog('æ­£åœ¨åŠ è½½ç³»ç»Ÿæ•°æ®...');
                        
                        // æ¨¡æ‹ŸåŠ è½½æ•°æ®
                        const mockTasks = [
                            { id: '1', taskCode: 'TASK-001', quantity: 100, completedQuantity: 50, status: 'è¿›è¡Œä¸­', processType: 'æ³¨å¡‘' },
                            { id: '2', taskCode: 'TASK-002', quantity: 200, completedQuantity: 200, status: 'è¿›è¡Œä¸­', processType: 'æ³¨å¡‘' },
                            { id: '3', taskCode: 'TASK-003', quantity: 150, completedQuantity: 0, status: 'å·²å®Œæˆ', processType: 'å°åˆ·' }
                        ];

                        const mockInjectionParams = [
                            { id: 1, taskId: '1', quantity: 80, pressure: 100, injectionSpeed: 50 },
                            { id: 2, taskId: '2', quantity: 200, pressure: 120, injectionSpeed: 60 }
                        ];

                        systemData.value = {
                            tasks: mockTasks,
                            injectionParams: mockInjectionParams,
                            patterns: [],
                            plans: []
                        };

                        addLog('ç³»ç»Ÿæ•°æ®åŠ è½½å®Œæˆ');
                    } catch (error) {
                        addLog('åŠ è½½ç³»ç»Ÿæ•°æ®å¤±è´¥: ' + error.message);
                    }
                };

                const performHealthCheck = async () => {
                    isChecking.value = true;
                    addLog('å¼€å§‹æ‰§è¡Œç³»ç»Ÿå¥åº·æ£€æŸ¥...');

                    try {
                        // æ¨¡æ‹Ÿå¥åº·æ£€æŸ¥
                        await new Promise(resolve => setTimeout(resolve, 2000));

                        const results = {
                            timestamp: new Date().toISOString(),
                            overallHealth: 'warning',
                            checks: {
                                dataConsistency: {
                                    name: 'æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥',
                                    status: 'warning',
                                    issues: 2,
                                    severity: 'warning'
                                },
                                taskStatus: {
                                    name: 'ä»»åŠ¡çŠ¶æ€æ£€æŸ¥',
                                    status: 'warning',
                                    issues: 1,
                                    severity: 'warning'
                                },
                                quantityLogic: {
                                    name: 'æ•°é‡é€»è¾‘æ£€æŸ¥',
                                    status: 'pass',
                                    issues: 0,
                                    severity: 'info'
                                },
                                permissions: {
                                    name: 'æƒé™é…ç½®æ£€æŸ¥',
                                    status: 'pass',
                                    issues: 0,
                                    severity: 'info'
                                }
                            },
                            issues: [
                                { check: 'æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥', count: 2 }
                            ],
                            warnings: [
                                { check: 'ä»»åŠ¡çŠ¶æ€æ£€æŸ¥', count: 1 }
                            ]
                        };

                        checkResults.value = results;
                        
                        // ç”Ÿæˆä¿®å¤å»ºè®®
                        suggestions.value = [
                            {
                                priority: 'high',
                                title: 'ä¿®å¤æ•°æ®ä¸ä¸€è‡´é—®é¢˜',
                                description: 'å‘ç°2é¡¹ä»»åŠ¡æ•°é‡ä¸å·¥è‰ºå‚æ•°æ•°é‡ä¸ä¸€è‡´',
                                action: 'autoFixDataInconsistency'
                            },
                            {
                                priority: 'medium',
                                title: 'æ›´æ–°ä»»åŠ¡çŠ¶æ€',
                                description: 'å‘ç°1ä¸ªä»»åŠ¡çŠ¶æ€éœ€è¦æ›´æ–°',
                                action: 'updateTaskStatus'
                            }
                        ];

                        addLog('ç³»ç»Ÿå¥åº·æ£€æŸ¥å®Œæˆ');
                        ElNotification({
                            title: 'å¥åº·æ£€æŸ¥å®Œæˆ',
                            message: 'å‘ç°ä¸€äº›éœ€è¦å…³æ³¨çš„é—®é¢˜',
                            type: 'warning'
                        });
                    } catch (error) {
                        addLog('å¥åº·æ£€æŸ¥å¤±è´¥: ' + error.message);
                        ElMessage.error('å¥åº·æ£€æŸ¥å¤±è´¥');
                    } finally {
                        isChecking.value = false;
                    }
                };

                const autoFixIssues = async () => {
                    isFixing.value = true;
                    addLog('å¼€å§‹è‡ªåŠ¨ä¿®å¤é—®é¢˜...');

                    try {
                        const autoFixSuggestions = suggestions.value.filter(s => 
                            s.action && s.action.startsWith('auto')
                        );

                        for (const suggestion of autoFixSuggestions) {
                            addLog(`æ­£åœ¨ä¿®å¤: ${suggestion.title}`);
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            
                            if (suggestion.action === 'autoFixDataInconsistency') {
                                // æ¨¡æ‹Ÿä¿®å¤æ•°æ®ä¸ä¸€è‡´
                                fixedIssues.value += 2;
                                addLog('å·²ä¿®å¤2é¡¹æ•°æ®ä¸ä¸€è‡´é—®é¢˜');
                            }
                        }

                        // ç§»é™¤å·²ä¿®å¤çš„å»ºè®®
                        suggestions.value = suggestions.value.filter(s => 
                            !s.action || !s.action.startsWith('auto')
                        );

                        addLog('è‡ªåŠ¨ä¿®å¤å®Œæˆ');
                        ElMessage.success('è‡ªåŠ¨ä¿®å¤å®Œæˆ');
                    } catch (error) {
                        addLog('è‡ªåŠ¨ä¿®å¤å¤±è´¥: ' + error.message);
                        ElMessage.error('è‡ªåŠ¨ä¿®å¤å¤±è´¥');
                    } finally {
                        isFixing.value = false;
                    }
                };

                const applySuggestion = async (suggestion) => {
                    addLog(`åº”ç”¨ä¿®å¤å»ºè®®: ${suggestion.title}`);
                    
                    try {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        // ç§»é™¤å·²åº”ç”¨çš„å»ºè®®
                        const index = suggestions.value.indexOf(suggestion);
                        if (index > -1) {
                            suggestions.value.splice(index, 1);
                        }
                        
                        fixedIssues.value += 1;
                        addLog(`ä¿®å¤å»ºè®®åº”ç”¨æˆåŠŸ: ${suggestion.title}`);
                        ElMessage.success('ä¿®å¤å»ºè®®åº”ç”¨æˆåŠŸ');
                    } catch (error) {
                        addLog(`ä¿®å¤å»ºè®®åº”ç”¨å¤±è´¥: ${error.message}`);
                        ElMessage.error('ä¿®å¤å»ºè®®åº”ç”¨å¤±è´¥');
                    }
                };

                const generateReport = () => {
                    if (!checkResults.value) {
                        ElMessage.warning('è¯·å…ˆæ‰§è¡Œå¥åº·æ£€æŸ¥');
                        return;
                    }

                    const report = generateHealthReport(checkResults.value);
                    addLog('ç”Ÿæˆæ£€æŸ¥æŠ¥å‘Š:\n' + report);
                    
                    // ä¸‹è½½æŠ¥å‘Š
                    const blob = new Blob([report], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `MESç³»ç»Ÿå¥åº·æ£€æŸ¥æŠ¥å‘Š_${new Date().toISOString().slice(0, 10)}.txt`;
                    a.click();
                    URL.revokeObjectURL(url);
                };

                const showCheckDetails = (check) => {
                    ElMessageBox.alert(
                        `æ£€æŸ¥é¡¹ç›®: ${check.name}\nçŠ¶æ€: ${check.status}\né—®é¢˜æ•°é‡: ${check.issues || 0}`,
                        'æ£€æŸ¥è¯¦æƒ…',
                        { confirmButtonText: 'ç¡®å®š' }
                    );
                };

                const clearLog = () => {
                    logContent.value = 'æ—¥å¿—å·²æ¸…ç©º\n';
                };

                const getCheckDescription = (check) => {
                    const descriptions = {
                        'æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥': 'æ£€æŸ¥ä»»åŠ¡æ•°é‡ä¸å·¥è‰ºå‚æ•°æ•°é‡çš„ä¸€è‡´æ€§',
                        'ä»»åŠ¡çŠ¶æ€æ£€æŸ¥': 'æ£€æŸ¥ä»»åŠ¡çŠ¶æ€æ˜¯å¦éœ€è¦æ›´æ–°',
                        'æ•°é‡é€»è¾‘æ£€æŸ¥': 'æ£€æŸ¥å„é¡µé¢æ•°é‡é€»è¾‘çš„æ­£ç¡®æ€§',
                        'æƒé™é…ç½®æ£€æŸ¥': 'æ£€æŸ¥æƒé™é…ç½®æ˜¯å¦æ­£ç¡®'
                    };
                    return descriptions[check.name] || '';
                };

                const getTagType = (status) => {
                    const types = {
                        'pass': 'success',
                        'warning': 'warning',
                        'fail': 'danger'
                    };
                    return types[status] || 'info';
                };

                const getStatusText = (status) => {
                    const texts = {
                        'pass': 'é€šè¿‡',
                        'warning': 'è­¦å‘Š',
                        'fail': 'å¤±è´¥'
                    };
                    return texts[status] || 'æœªçŸ¥';
                };

                const getSuggestionType = (priority) => {
                    const types = {
                        'high': 'error',
                        'medium': 'warning',
                        'low': 'info'
                    };
                    return types[priority] || 'info';
                };

                const calculateHealthScore = (results) => {
                    if (!results || !results.checks) return 0;
                    
                    const checks = Object.values(results.checks);
                    let score = 100;
                    
                    checks.forEach(check => {
                        if (check.severity === 'critical') {
                            score -= 20;
                        } else if (check.severity === 'warning') {
                            score -= 10;
                        }
                    });
                    
                    return Math.max(0, score);
                };

                const generateHealthReport = (results) => {
                    const score = calculateHealthScore(results);
                    
                    let report = `MESç³»ç»Ÿå¥åº·æ£€æŸ¥æŠ¥å‘Š\n`;
                    report += `=====================\n`;
                    report += `æ£€æŸ¥æ—¶é—´: ${new Date(results.timestamp).toLocaleString()}\n`;
                    report += `å¥åº·è¯„åˆ†: ${score}/100\n`;
                    report += `æ€»ä½“çŠ¶æ€: ${results.overallHealth}\n\n`;

                    report += `æ£€æŸ¥é¡¹ç›®:\n`;
                    Object.values(results.checks).forEach((check, index) => {
                        report += `${index + 1}. ${check.name}: ${check.status.toUpperCase()}\n`;
                        if (check.issues > 0) {
                            report += `   é—®é¢˜æ•°é‡: ${check.issues}\n`;
                        }
                    });

                    return report;
                };

                onMounted(() => {
                    loadSystemData();
                });

                return {
                    isChecking,
                    isFixing,
                    checkResults,
                    suggestions,
                    logContent,
                    logArea,
                    systemHealth,
                    healthScore,
                    criticalIssues,
                    warnings,
                    fixedIssues,
                    canAutoFix,
                    performHealthCheck,
                    autoFixIssues,
                    applySuggestion,
                    generateReport,
                    showCheckDetails,
                    clearLog,
                    getCheckDescription,
                    getTagType,
                    getStatusText,
                    getSuggestionType
                };
            }
        }).use(ElementPlus).mount('#app');
    </script>
</body>
</html>