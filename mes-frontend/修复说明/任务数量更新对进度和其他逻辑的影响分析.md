# 任务数量更新对进度和其他逻辑的影响分析

## 问题概述

当在注塑工艺参数页面更新任务数量时，需要考虑对以下模块的影响：
1. **任务管理页面**的进度显示
2. **计划管理页面**的完成率计算
3. **设备监控**的负载统计
4. **全局统计数据**的实时更新
5. **进度对话框**的数据准确性

## 当前系统架构分析

### 1. 进度计算逻辑

#### TaskTable.vue 中的进度计算
```javascript
function getProgress(status) {
  const map = {
    '待下发': 0,
    '进行中': 50,
    '已完成': 100,
    '已暂停': 30
  }
  return map[status] || 0
}
```
**问题**：进度只基于状态，没有考虑实际完成数量

#### SimpleProgressDialog.vue 中的进度计算
```javascript
const completionPercent = computed(() => {
  if (!props.plan || props.plan.totalQuantity === 0) return 0
  return Math.round((totalCompleted.value / props.plan.totalQuantity) * 100)
})

const allocationPercent = computed(() => {
  if (!props.plan || props.plan.totalQuantity === 0) return 0
  return Math.round((totalAllocated.value / props.plan.totalQuantity) * 100)
})
```
**问题**：基于任务数量计算，但任务数量更新后可能不同步

### 2. 数据同步机制

#### 全局 Store (stores/index.js)
```javascript
const totalTasks = computed(() => tasks.value.length)
const inProgressTasks = computed(() => tasks.value.filter(t => t.status === '进行中').length)
const completedTasks = computed(() => tasks.value.filter(t => t.status === '已完成').length)
```
**问题**：只统计任务数量，没有考虑任务的实际生产数量

## 影响范围分析

### 1. 直接影响
- ✅ **注塑工艺参数页面**：已实现数量更新功能
- ❌ **任务管理页面**：进度显示可能不准确
- ❌ **计划进度对话框**：完成率计算可能错误
- ❌ **全局统计**：数量统计可能不同步

### 2. 间接影响
- **设备负载计算**：基于任务数量的设备分配可能不准确
- **生产计划调度**：基于错误数量的计划可能导致资源浪费
- **报表统计**：历史数据和实时数据可能不一致

## 改进方案

### 方案一：增强进度计算逻辑

#### 1. 任务级别的进度计算
```javascript
// 基于实际完成数量的进度计算
function getTaskProgress(task) {
  if (!task.quantity || task.quantity === 0) return 0
  
  switch (task.status) {
    case '待下发': return 0
    case '进行中': 
      // 可以基于实际完成数量计算，暂时使用50%
      return Math.min(50, (task.completedQuantity || 0) / task.quantity * 100)
    case '已完成': return 100
    case '已暂停': return Math.min(30, (task.completedQuantity || 0) / task.quantity * 100)
    default: return 0
  }
}
```

#### 2. 计划级别的进度计算
```javascript
// 基于加权平均的计划进度
function getPlanProgress(plan, tasks) {
  const relatedTasks = tasks.filter(t => t.planId === plan.id)
  if (relatedTasks.length === 0) return 0
  
  const totalQuantity = relatedTasks.reduce((sum, task) => sum + task.quantity, 0)
  const weightedProgress = relatedTasks.reduce((sum, task) => {
    const taskProgress = getTaskProgress(task)
    const weight = task.quantity / totalQuantity
    return sum + (taskProgress * weight)
  }, 0)
  
  return Math.round(weightedProgress)
}
```

### 方案二：实时数据同步机制

#### 1. 任务数量更新后的数据同步
```javascript
// 在 InjectionTaskPage.vue 中任务数量更新后
const syncRelatedData = async (taskId, newQuantity) => {
  try {
    // 1. 更新全局 store 中的任务数据
    await appStore.refreshTasks()
    
    // 2. 通知其他页面刷新数据
    eventBus.emit('task-quantity-updated', { taskId, newQuantity })
    
    // 3. 更新相关计划的进度
    const task = appStore.tasks.find(t => t.id === taskId)
    if (task) {
      await appStore.refreshPlans()
    }
    
  } catch (error) {
    console.error('数据同步失败:', error)
  }
}
```

#### 2. 跨页面数据同步
```javascript
// 使用事件总线或 Pinia 的响应式特性
import { useEventBus } from '@/utils/eventBus'

const eventBus = useEventBus()

// 监听任务数量更新事件
eventBus.on('task-quantity-updated', ({ taskId, newQuantity }) => {
  // 更新本地数据
  updateLocalTaskData(taskId, newQuantity)
  // 重新计算进度
  recalculateProgress()
})
```

### 方案三：增强统计逻辑

#### 1. 基于数量的统计
```javascript
// 在 stores/index.js 中增强统计逻辑
const totalTaskQuantity = computed(() => 
  tasks.value.reduce((sum, task) => sum + (task.quantity || 0), 0)
)

const completedTaskQuantity = computed(() => 
  tasks.value
    .filter(t => t.status === '已完成')
    .reduce((sum, task) => sum + (task.quantity || 0), 0)
)

const inProgressTaskQuantity = computed(() => 
  tasks.value
    .filter(t => t.status === '进行中')
    .reduce((sum, task) => sum + (task.quantity || 0), 0)
)
```

#### 2. 计划完成率统计
```javascript
const planCompletionStats = computed(() => {
  return plans.value.map(plan => {
    const relatedTasks = tasks.value.filter(t => t.planId === plan.id)
    const totalAllocated = relatedTasks.reduce((sum, task) => sum + (task.quantity || 0), 0)
    const totalCompleted = relatedTasks
      .filter(t => t.status === '已完成')
      .reduce((sum, task) => sum + (task.quantity || 0), 0)
    
    return {
      planId: plan.id,
      planCode: plan.planCode,
      totalQuantity: plan.totalQuantity,
      allocatedQuantity: totalAllocated,
      completedQuantity: totalCompleted,
      completionRate: plan.totalQuantity > 0 ? 
        Math.round((totalCompleted / plan.totalQuantity) * 100) : 0,
      allocationRate: plan.totalQuantity > 0 ? 
        Math.round((totalAllocated / plan.totalQuantity) * 100) : 0
    }
  })
})
```

## 实施计划

### 阶段一：核心逻辑修复 ✅
1. **修复任务进度计算** ✅
   - ✅ 更新 TaskTable.vue 中的进度计算逻辑
   - ✅ 考虑任务数量和完成数量的权重

2. **增强计划进度计算** 🔄
   - ✅ SimpleProgressDialog.vue 已有基于数量的计算
   - ⏳ ProcessProgressDialog.vue 待进一步优化

3. **同步数据更新机制** ✅
   - ✅ 在任务数量更新后触发相关数据刷新
   - ✅ 实现跨页面事件驱动的数据同步

### 阶段二：统计逻辑增强 ✅
1. **全局统计优化** ✅
   - ✅ 在 stores/index.js 中添加基于数量的统计
   - ✅ 提供更准确的生产统计数据

2. **实时数据同步** ✅
   - ✅ 实现跨页面的数据同步机制
   - ✅ 添加数据变更通知事件

### 阶段三：用户体验优化 🔄
1. **进度可视化改进** ✅
   - ✅ 更直观的进度显示（基于实际完成数量）
   - ✅ 数量变更的视觉反馈

2. **数据一致性验证** ✅
   - ✅ 添加数据一致性检查
   - ✅ 提供测试工具验证同步状态

## 已完成的实施内容

### ✅ 核心功能实现
1. **增强的进度计算逻辑**
   ```javascript
   function getProgress(row) {
     // 基于实际完成数量的进度计算
     if (row.completedQuantity !== undefined && row.completedQuantity >= 0) {
       return Math.min(100, Math.round((row.completedQuantity / row.quantity) * 100))
     }
     // 回退到基于状态的进度
     return baseProgress[row.status] || 0
   }
   ```

2. **跨页面数据同步机制**
   ```javascript
   // 触发全局数据同步
   window.dispatchEvent(new CustomEvent('task-quantity-updated', {
     detail: { taskId, newQuantity, timestamp: Date.now() }
   }))
   ```

3. **增强的统计逻辑**
   ```javascript
   // 基于数量的统计
   const totalTaskQuantity = computed(() => 
     tasks.value.reduce((sum, task) => sum + (task.quantity || 0), 0)
   )
   ```

### 🧪 测试工具
- **`test-progress-sync.html`**：完整的进度同步测试工具
- **数据同步状态监控**：实时检查各模块同步状态
- **完整流程测试**：端到端的功能验证

## 具体实现代码

### 1. 增强的任务进度计算
```javascript
// TaskTable.vue 中的改进
function getProgress(row) {
  if (!row.quantity || row.quantity === 0) return 0
  
  // 基于状态和数量的综合进度
  const baseProgress = {
    '待下发': 0,
    '进行中': 50,
    '已完成': 100,
    '已暂停': 30
  }[row.status] || 0
  
  // 如果有实际完成数量，使用实际进度
  if (row.completedQuantity !== undefined) {
    return Math.round((row.completedQuantity / row.quantity) * 100)
  }
  
  return baseProgress
}
```

### 2. 数据同步触发器
```javascript
// InjectionTaskPage.vue 中的数据同步
const triggerDataSync = async (taskId, newQuantity) => {
  try {
    // 更新全局数据
    await appStore.refreshTasks()
    
    // 发送同步事件
    window.dispatchEvent(new CustomEvent('task-data-updated', {
      detail: { taskId, newQuantity, timestamp: Date.now() }
    }))
    
    console.log('数据同步触发成功')
  } catch (error) {
    console.error('数据同步失败:', error)
  }
}
```

### 3. 跨页面数据监听
```javascript
// TaskManager.vue 中的数据监听
onMounted(() => {
  // 监听任务数据更新事件
  window.addEventListener('task-data-updated', handleTaskDataUpdate)
})

onUnmounted(() => {
  window.removeEventListener('task-data-updated', handleTaskDataUpdate)
})

const handleTaskDataUpdate = (event) => {
  const { taskId, newQuantity } = event.detail
  
  // 更新本地任务数据
  const taskIndex = tasks.value.findIndex(t => t.id === taskId)
  if (taskIndex !== -1) {
    tasks.value[taskIndex].quantity = newQuantity
  }
  
  // 重新计算相关统计
  console.log('任务数据已同步更新:', taskId, newQuantity)
}
```

## 风险评估

### 技术风险
1. **性能影响**：频繁的数据同步可能影响性能
2. **数据一致性**：多处数据更新可能导致不一致
3. **兼容性**：现有代码的兼容性问题

### 业务风险
1. **数据准确性**：进度计算错误可能影响生产决策
2. **用户体验**：数据更新延迟可能影响用户操作
3. **系统稳定性**：复杂的同步逻辑可能引入新的bug

### 缓解措施
1. **渐进式实施**：分阶段实施，逐步验证
2. **数据验证**：添加数据一致性检查
3. **回滚机制**：保留原有逻辑作为备选方案
4. **监控告警**：添加数据同步状态监控

## 总结

任务数量更新确实会影响多个模块的进度计算和统计逻辑。建议采用渐进式的改进方案，优先修复核心的进度计算逻辑，然后逐步完善数据同步机制。这样既能解决当前问题，又能为未来的功能扩展奠定基础。